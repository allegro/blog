---
layout: post
title: "Web icons 2024"
author: [pawel.lesiecki, maciej.suszko]
tags: [tech, web, svg, css, html]
---
Hello fellow Web developers!

Icons are an integral part of most modern UIs.
What is the best way to embed icons nowadays?
Feels like this area is full of pitfalls so better proceed with caution trying to answer that question.

There are plenty of possibilities, [some of them are considered harmful](https://twitter.com/_developit/status/1382838799420514317) though.

It seems, due to the lack of good alternatives, various inline SVG techniques got more popular over the years, although not leveraging the cache is a huge trade-off.

Thankfully, [there are some voices of reason](https://twitter.com/getifyX/status/1720810762409566459) in the community.

At Allegro we've used SVG and CSS filters for quite some time.

However it has its limits and it isn't necessarily perfect for the future challenges of the themeable design system.

Let's stop for a moment and try to rethink the approach to icons.

It has to meet several requirements:
- themeable, 
- cacheable, 
- easily embeddable.

## Can we do better than we have so far?

Could the platform be so vast that it has some uncharted territories?
Fortunately, it turns out that the platform is capable of dealing with icons more efficiently.

**Here we'd like to introduce the SVG+CSS technique that lets you have a 3-color icon utilizing just a single DOM element and a single external SVG.**

Because we haven't really found anything regarding similar techniques, neither on google nor on github nor twitter, we'd like to share this idea with you.
Besides, ChatGPT wasn't able to provide a similar solution, it was quite close, although it was missing major details.

Please consider the proposed technique if you care about performance. 

### Key benefits are:

1. Caching.
2. Works cross-domain.
3. Customizable more than single color.
4. Icons load after critical resources and content, don't bloat the markup.

We’re going to control 3 different parts color with just a single DOM element and single SVG resource.

Sounds interesting? Then, let's dive into how we can accomplish this.

## Implementation

SVG and CSS are gifts that keep on giving, both combined can do wonders.

Proposed technique is a combination of two capabilities of the platform.
1. [SVG Fragments](https://css-tricks.com/svg-fragment-identifiers-work/)
2. [CSS Masks](https://developer.mozilla.org/en-US/docs/Web/CSS/mask-image)

As a case study let's pick one of our icons — ![a-icon](https://a.allegroimg.com/original/34bbe1/2be1acde4b8aa1b2a255d958fd59/illustration-allego-in-circle-big-db0c91e439).

With source like:

```svg
<svg viewBox="0 0 32 32" fill="none" height="32" width="32" xmlns="http://www.w3.org/2000/svg">
  <path d="..." fill="#B0B8BC"></path>
  <path clip-rule="evenodd" d="..." fill-rule="evenodd" fill="#FF7B33"></path>
  <path d="..." fill="#D9DFE4"></path>
</svg>
```

This particular icon consists of 3 parts with different colors each and we’re going to control these colors by the main document’s CSS.

It’s time to program in SVG and CSS for a moment.

### Step #1 — SVG Fragments

First let’s craft our test subject and introduce the fragments. Each `path` gets a unique Fragment Identifier by setting an `id` attribute. Next, we add a little CSS to enable rendering fragments in isolation. Think of it as kind of an image sprite.

For sake of CSS simplicity, we group all the paths under an extra `g` element with a unique `id` as well.

As a result, the SVG is supposed to look like this:

```html
<svg viewBox="0 0 32 32" fill="none" height="32" width="32" xmlns="http://www.w3.org/2000/svg">
  <style>
    path:not(:target) {
      display: none;
    }
    g:target path {
      display: inline;
    }
  </style>
  <g id="icon">
    <path id="border" d="..." fill="#B0B8BC"></path>
    <path id="a" clip-rule="evenodd" d="..." fill-rule="evenodd" fill="#FF7B33"></path>
    <path id="shadow" d="..." fill="#D9DFE4"></path>
  </g>
</svg>
```

It gives 4 fragments in total, one for each of three paths and the last one for the whole icon.
Each of them can be now rendered as a separate image:

1. [`#a`](https://a.allegroimg.com/original/34febb/41e35d7d46f59e55126cd59bfba7/illustration-allego-in-circle-big-13199eba11#a) — ![`#a`](https://a.allegroimg.com/original/34febb/41e35d7d46f59e55126cd59bfba7/illustration-allego-in-circle-big-13199eba11#a)
2. [`#border`](https://a.allegroimg.com/original/34febb/41e35d7d46f59e55126cd59bfba7/illustration-allego-in-circle-big-13199eba11#border) — ![`#border`](https://a.allegroimg.com/original/34febb/41e35d7d46f59e55126cd59bfba7/illustration-allego-in-circle-big-13199eba11#border)
3. [`#shadow`](https://a.allegroimg.com/original/34febb/41e35d7d46f59e55126cd59bfba7/illustration-allego-in-circle-big-13199eba11#shadow) — ![`#shadow`](https://a.allegroimg.com/original/34febb/41e35d7d46f59e55126cd59bfba7/illustration-allego-in-circle-big-13199eba11#shadow)
4. [`#icon`](https://a.allegroimg.com/original/34febb/41e35d7d46f59e55126cd59bfba7/illustration-allego-in-circle-big-13199eba11#icon) — ![`#icon`](https://a.allegroimg.com/original/34febb/41e35d7d46f59e55126cd59bfba7/illustration-allego-in-circle-big-13199eba11#icon)

Now the regular fragment-less URL will display a blank image.
Therefore, for the full icon we’re going to add a [`#icon`](https://a.allegroimg.com/original/34febb/41e35d7d46f59e55126cd59bfba7/illustration-allego-in-circle-big-13199eba11#icon) fragment to the URL.

Actually, we're not going to use the `#a` fragment, but let's keep its identifier.

### Step #2 — CSS Masks

With SVG Fragment Identifiers up and ready we can proceed with leveraging CSS masking capabilities.

The base class `.icon` stacks three layers on top of each other ready for CSS masks.

```css
.icon {
  position: relative;
  width: 32px;
  height: 32px;
  mask-repeat: no-repeat;
}
.icon::before,
.icon::after {
  content: '';
  position: absolute;
  width: inherit;
  height: inherit;
}
```

Last CSS class is for our specific icon.

```css
.icon--a {
  mask-image: url('./a.svg#icon'); /* full icon’s shape */
  background-color: #FF7B33;
}
.icon--a::before {
  mask-image: url('./a.svg#shadow'); /* shadow’s shape */
  background-color: #D9DFE4;
}
.icon--a::after {
  mask-image: url('./a.svg#border'); /* border’s shape */
  background-color: #B0B8BC;
}
```

The key part is that we picked the whole icon, not any fragment of it, as the parent's mask, so we have the whole icon visible. That’s because the parent layer masks its children.

We selected an orange color of "a" for the parent layer.
Then we put the two remaining layers on it.
The second and third layers are for shadow and border parts respectively.

**We can describe this as a cutout of the whole icon in one particular color covered by one or more shapes in different colors.**

In case an icon has intersecting parts, keep in mind that background colors render on top of each other in particular order:
1. the parent’s background,
2. the `::before` pseudo-element’s background,
3. the `::after`’s background at the end.

As a result, we can embed the icon by a single element.
```html
<div class="icon icon--a"></div>
```

The result is supposed to look like the original icon from the start — ![the original icon from the start](https://a.allegroimg.com/original/34bbe1/2be1acde4b8aa1b2a255d958fd59/illustration-allego-in-circle-big-db0c91e439).

Therefore, the single element gives us control over up to three different parts of our icon and we can change colors independently and dynamically.

## The demo
Feel free to check the [demo](https://three-colors-one-element-icon.plesiecki.repl.co/).

Pretty neat, isn’t it?

We found this technique practical and we're keen to use it in the future.

## More colors
In case you need more than 3 colors you could switch from pseudo-elements to regular elements and stack as many layers as you want. Also, you might consider doing `background-image` plus gradient instead of `background-color` for more colors.

Enjoy & happy coding!
